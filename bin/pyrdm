#!/usr/bin/env python

#    Copyright (C) 2014 Christian T. Jacobs, Alexandros Avdis, Gerard J. Gorman, Matthew D. Piggott.

#    This file is part of PyRDM.

#    PyRDM is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    PyRDM is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with PyRDM.  If not, see <http://www.gnu.org/licenses/>.

import sys, os, glob
import ConfigParser
import optparse
import re

import libspud
import git
from xml.dom import minidom

pyrdm_path = os.path.join(os.path.realpath(os.path.dirname(__file__)), os.pardir)
sys.path.insert(0, pyrdm_path)

from pyrdm.publisher import Publisher

class PyRDM:

   def __init__(self, options_file):
      self.options_file = options_file
      return

   def get_fluidity_version(self):
      print "Reading SHA-1 hash..."
      # FIXME: Here we are assuming that the Fluidity binary is in the same Git repository as the options file. Is there a better way of doing this?
      repo = git.Repo(sys.argv[-1])
      f = open(repo.working_dir + "/include/version.h", "r")
      f.readline()
      f.readline()
      l = f.readline()
      sha = l.split()[-1].replace("\"", "")
      f.close()
      print "SHA-1 hash: ", sha
      return sha

   def write_provenance_data(self):
      # Get the path to the stat file.
      simulation_name = libspud.get_option("/simulation_name")
      stat_path = os.path.dirname(sys.argv[-1]) + "/" + simulation_name + ".stat"

      # The following code is based on fluidity_tools.py:
      stat = open(stat_path, "r")
      header_re = re.compile(r"</header>")

      # Get the header.
      xml = ""
      while True:
         line = stat.readline()
         if(line == ""):
            raise Exception("Unable to read .stat file header")
         xml = xml + line
         if(re.search(header_re, line)):
            break

      # Get the body.
      body = ""
      while True:
         line = stat.readline()
         if(line == ""):
            break
         body = body + line

      stat.close()

      # Parse the XML
      xml = minidom.parseString(xml)

      # Check that the FLUIDITY_VERSION in the stat file is the same as the published version.
      sha = self.get_fluidity_version()
      for element in xml.getElementsByTagName('constant'):
         if(element.attributes["name"].value == "FluidityVersion"):
            sha_in_statfile = element.attributes["value"].value
            break
      if(libspud.have_option("/publish/software/article_id")):
         if(libspud.get_option("/publish/software/article_id") != self.publisher.find_software("Fluidity", sha_in_statfile)):
            print "The version of Fluidity that created this output data is not the same as the published version of Fluidity."
            print "Please re-publish the software with the correct version (or re-run the simulation with an updated version) and try again."
            #sys.exit(1) #TODO: Re-enable this later.

      # Append the provenance data
      provenance_data = {}
      if(libspud.have_option("/publish/software/doi")):
         provenance_data["SoftwareDOI"] = libspud.get_option("/publish/software/doi")
      else:
         provenance_data["SoftwareDOI"] = "Unknown"

      if(libspud.have_option("/publish/input_data/doi")):
         provenance_data["InputDataDOI"] = libspud.get_option("/publish/input_data/doi")
      else:
         provenance_data["InputDataDOI"] = "Unknown"

      elements = xml.getElementsByTagName('constant')
      for key in provenance_data.keys():
         exists = False
         for element in elements:
            if(element.getAttribute("name") == key):
               # Element already exists, so update the value attribute.
               exists = True
               element.setAttribute("value", provenance_data[key])
         if(not exists):
            # Element doesn't exist, so create it.
            element = xml.createElement("constant")
            element.setAttribute("name", key)
            element.setAttribute("type", "string")
            element.setAttribute("value", provenance_data[key])
            xml.childNodes[0].insertBefore(xml.createTextNode("\n"), xml.childNodes[0].childNodes[3]) # Add a new line
            xml.childNodes[0].insertBefore(element, xml.childNodes[0].childNodes[3]) # Append the provenance data

      # Write the changes to the stat file.
      header = xml.toprettyxml(newl="", indent="")
      header = header.replace("<?xml version=\"1.0\" ?>", "")
      stat = open(stat_path, "w")
      stat.write(header + "\n" + body)
      stat.close()

      return

   def publish(self, data_type, version=None):
      libspud.load_options(self.options_file)

      service = libspud.get_option("/publish/service")
      self.publisher = Publisher(service=service)

      if(data_type == "s"):
         # Publish the software
         
         # Get the SHA-1 hash of the software version.
         if(version is None):
            sha = self.get_fluidity_version()
         else:
            print "Using the software version provided: %s" % version
            sha = version

         # Search for the software, in case it has already been published.
         article_id = self.publisher.find_software("Fluidity", sha)
         print article_id
         
         options_path = "/publish/software/"
         if(article_id is None):
            # Software is not published already, so publish it now.            
            publication_details = self.publisher.publish_software("Fluidity", sha, local_repo_location=sys.argv[-1])
            try:
               libspud.set_option(options_path + "/article_id", str(publication_details["article_id"]))
            except:
               pass # Ignore any SPUD_NEW_KEY_WARNING warnings
            #libspud.set_option("/publish/software/doi", str(doi)) # FIXME: Uncomment this once the article status is set to 'public'.
         else:
            try:
               libspud.set_option(options_path + "/article_id", str(article_id))
            except:
               pass # Ignore any SPUD_NEW_KEY_WARNING warnings
            #libspud.set_option("/publish/software/doi", str(doi)) # FIXME: Uncomment this once the article status is set to 'public'.
         libspud.write_options(self.options_file)
            
      else:
         # Publish the input/output data
         if(data_type == "i"):
            options_path = "/publish/input_data/"
         elif(data_type == "o"):
            options_path = "/publish/output_data/"
         else:
            print "Data type not recognised."
            sys.exit(1)
            
         if(libspud.have_option(options_path + "/article_id")):
            article_id = libspud.get_option(options_path + "/article_id")
         else:
            article_id = None

         # A list of paths to files that the user wants published.
         temp = eval(libspud.get_option(options_path + "/files"))
         # Change the file paths to be relative to the directory where the options file is stored.
         for i in range(len(temp)):
            temp[i] = os.path.dirname(sys.argv[-1]) + "/" + temp[i]

         files = []
         for i in range(len(temp)):
            if("*" in os.path.basename(temp[i])):
               # Expand out any wildcard expressions.
               expanded = glob.glob(temp[i])
               for j in range(len(expanded)):
                  files.append(expanded[j])
            else:
               files.append(temp[i])

         if(data_type == "o"):
            # Write provenance data to the stat file.
            self.write_provenance_data()

         if(data_type == "i"):
            title = "Input data files for simulation: %s" % libspud.get_option("/simulation_name")
         elif(data_type == "o"):
            title = "Output data files for simulation: %s" % libspud.get_option("/simulation_name")
         parameters = {"title":title, "description":"", "files":files}
         publication_details = self.publisher.publish_data(parameters, article_id)

         # Write the article_id and DOI to the options file for next time.
         if(article_id is None):
            try:
               libspud.set_option(options_path + "/article_id", str(publication_details["article_id"]))
            except:
               pass # Ignore any SPUD_NEW_KEY_WARNING warnings
            try:
               libspud.set_option(options_path + "/doi", str(publication_details["doi"]))
            except:
               pass # Ignore any SPUD_NEW_KEY_WARNING warnings
            libspud.write_options(self.options_file)

      return
         
if(__name__ == "__main__"):
   # Parse the command line arguments
   parser = optparse.OptionParser()
   parser.add_option("-s", "--software", action="store_true", default=False)
   parser.add_option("-i", "--input", action="store_true", default=False)
   parser.add_option("-o", "--output", action="store_true", default=False)
   parser.add_option("-v", "--version", action="store", type="string", default=None)
   (options, args) = parser.parse_args()
   
   # The data the user wants to publish (software, input data, or output data)
   if(options.software):
      data_type = "s"
   elif(options.input):
      data_type = "i"
   elif(options.output):
      data_type = "o"
   else:
      print "No data type given."
      sys.exit(1)
      
   rdm = PyRDM(options_file = sys.argv[-1])
   rdm.publish(data_type = data_type, version = options.version)
   
